练习1.29
利用辛普森公式求积分。
因为sum函数对每个a是无分别对待的，所以这里最好把公式拆一下。转化为：
[f(x)+4f(x+dx)+f(x+2dx)] + [f(x+2dx)+4f(x+3dx)+f(x+4dx)]+...
这样每次都是同一个形式，方便处理，term函数定义为：
(define (term x)
    (+ (fn x) (* 4 (fn (+ x dx))) (fn (+ x dx dx))))
而next函数每次递增2dx:
(define (add-2dx x) (+ x dx dx))

辛普森公式的精度比书中例子的精度更好，这是按照dx=0.01和dx=0.001计算得到的结果：
> (simpson 0 1 (lambda (x) (* x x x)) 0.01
)
0.2500000000000005
> (simpson 0 1 (lambda (x) (* x x x)) 0.001
)
0.2500000000000006
书中的精度是万分之2和百万分之2，辛普森公式精度精确到了小数点后16位。

练习1.30
改成迭代的问题不大，不过发现精度不一样了。真是奇怪。这是用迭代版本算出来的：
> (simpson 0 1 (lambda (x) (* x x x)) 0.01
)
0.25000000000000044
> (simpson 0 1 (lambda (x) (* x x x)) 0.001
)
0.25000000000000056
之所以精度不一样，我认为是加法的顺序导致的，递归版本是从后向前加，而迭代版本是从前向后加。

练习1.31
product跟sum类似，不过这个求pi的公式精度不怎么好，这是不同情况下的pi的近似值：
> (cal-pi 2 10)
3.275101041334807
> (cal-pi 2 100)
3.157030176455167
> (cal-pi 2 1000)
3.1431607055322752

可以看到，即便到1000，近似值才到0.002的精度。

把product改成迭代方式也跟前面类似，出现了精度问题，应该也是乘法顺序的问题，迭代版本是从前向后乘，而递归版本是从后向前乘。

练习1.32
accumulate是sum和product更一般的形式，值得一提的是，在第三章又对accumulate的形式做了进一步讨论，在第三章，accumulate对一个序列求累积，并且引入了流。

练习1.33
这个就是加上一个filter函数，filter函数对当前的值做判断，返回#t或者#f
